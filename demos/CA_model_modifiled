import cellpylib as cpl
from collections import defaultdict
import numpy as np

def innitialize_grid(p):
    """
    Returns a 2D numpy array with a 1 in the center,
    -1 in the other cells (with probability p) and 0 elsewhere
    
    # TODO: Eventually, this probability p should decrease with distance to center
    to better mimic the topology
    """

    assert GRIDSIZE_X % 2 != 0, f"Gridsize width should be odd {GRIDSIZE_X}"
    assert GRIDSIZE_Y % 2 != 0, f"Gridsize height should be odd {GRIDSIZE_X}"

    # Create empty array
    STARTING_GRID = np.zeros((GRIDSIZE_X,GRIDSIZE_Y))

    # Add -1 to it randomly with probability p
    ## Create grid of probabilities
    ## Update the values of our grid that met the probability threshold
    prob_grid = np.random.rand(GRIDSIZE_X,GRIDSIZE_Y)
    STARTING_GRID[prob_grid < p] = -1
    
    # Add the leader in the center, which has a 1
    ## Get the index of the center space of each dimension
    ## And update that coordinate of the STARTING_GRID
    center_x = int((GRIDSIZE_X-1)/2)
    center_y = int((GRIDSIZE_Y-1)/2)
    STARTING_GRID[center_x,center_y] = 1
    
    return STARTING_GRID

def q(alpha=2.0, scale=1.0):
    """
    Returns a random number from a power-law distribution.

    Parameters:
    alpha - the exponent characterizing the power-law scaling
    scale - the scale factor for the distribution, typically this would be related to the mean

    Returns:
    A number drawn from the power-law distribution
    """
    return (np.random.pareto(alpha) + 1) * scale

def innitialize_influence_grid(STARTING_GRID):
    """
    Returns a np.array of same size as STARTING_GRID, where each node has a certain influence
    given by the distribution q, and the center value gets a much bigger value by design
    
    TODO: Allow for the node influence to follow any q distribution
    """

    # Create an empty matrix
    INFLUENCE_GRID = np.zeros((GRIDSIZE_X,GRIDSIZE_Y)) #STARTING_GRID

    # Fill it with values
    for ix, iy in np.ndindex(STARTING_GRID.shape):
        # If the corresponding position of STARTING_GRID had -1
        if STARTING_GRID[iy, ix] == -1:
            # Give that influence grid coordinate an influence value
            INFLUENCE_GRID[iy, ix] = q()

    # Put a very high value on the center
    center_value = 100
    center_x = int((GRIDSIZE_X-1)/2)
    center_y = int((GRIDSIZE_Y-1)/2)
    INFLUENCE_GRID[center_x,center_y] = center_value

    return INFLUENCE_GRID


def d(x0,y0,x1,y1):
    """
    Returns the distance between two nodes of the grid given by their x and y indexes

    Example:
    If we have a 3x3 matrix and want to compute the distance between the top left node
    and a node in the center, we would call d(0,0,1,1)=1.414...
    i|-|-
    -|j|-
    -|-|-
    """
    return np.sqrt((x1-x0)**2 + (y1-y0)**2)


def g(x):
    """
    Increasing function of social distance.
    Used to scale the social impact between nodes
    
    TODO: Use network theory to use an even better function for distance scaling
    """
    return x**2

def I(ix,iy):
    """
    Social impact exerted on a particular node i (with coordinates ix and iy) by the other nodes
    Is is a function of the opinion and influence of our node (si, sigma_i),
    the individual fixation parameter (BETTA), the EXTERNAL_INFLUENCE parameter
    and the opinion and influence of other nodes 
    
    """
    
    # Retrieve the opinion and influence of our node
    s_i = INFLUENCE_GRID[ix,iy]
    sigma_i =  STARTING_GRID[ix,iy]

    # Compute the influence of the other nodes
    ## Notice that when there is no node in a coordinate, STARTING_GRID is 0
    influence_sum = 0

    for jx, jy in np.ndindex(STARTING_GRID.shape):    
        ## If we are not in the position of our node
        if not (ix == jx and iy == jy):
            ## And if we have a cell here (sigma_j != 0 or s_j != 0)
            sigma_j =  STARTING_GRID[jx,jy]
            s_j = INFLUENCE_GRID[jx,jy]
                        
            if s_j != 0:
                ### We need to add another term to the sum
                ### Recall that if there is no cell here, we just add a 0
                ### So we should be ok, plus it should be efficient enough
                influence_sum += (s_j * sigma_i * sigma_j )/d(ix,iy,jx,jy)

    return -s_i*BETTA - sigma_i*EXTERNAL_INFLUENCE - influence_sum #


def get_social_impact_grid(INFLUENCE_GRID):
    """
    Returns a grid with the corresponding social impact that every node has from the others
    """

    # Start with an empty matrix
    SOCIAL_IMPACT_GRID = np.zeros(INFLUENCE_GRID.shape)

    # Loop over values that have nodes and update them
    # with their corresponding social impact
    for ix, iy in np.ndindex(INFLUENCE_GRID.shape):
        if INFLUENCE_GRID[ix,iy] != 0:
            
            impact = I(ix,iy)

            SOCIAL_IMPACT_GRID[ix,iy] = impact

    return SOCIAL_IMPACT_GRID